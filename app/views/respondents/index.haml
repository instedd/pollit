- unless wizard?
  - add_breadcrumb _("Respondents"), poll_respondents_path(@poll)
  = render :partial => 'shared/poll_tabs', :locals => { :poll => @poll, :active_tab => 'respondents' }

- content_for :head do
  = angular_js_include_tag

%div{:class => :content}
  %h1 Bulk respondents importing
  .whitebox{:style => "margin-top:-12px;"}
    Add respondents manually or upload a CSV file
    %br
    %br
    - unless can_edit
      Because the poll has already started, you can only add respondents. New respondents will be invited after you click 'Save'.
      %br
      %br
    #export_csv{onclick: "window.location = '#{export_csv_poll_respondents_path}'"}
      = button_tag :type => :button, :class => :fimport do
        %b Download a sample csv file
        and fill it with the phone numbers and/or twitter numbers
    #import_csv
      = button_tag :type => :button, :class => :fimport do
        %b Upload it for bulk respondents creation

%br

= content_tag :div, "ng:controller" => "RespondentsController" do
  %ul{:class => "clist"}
    %li{"ng:repeat" => "respondent in fixed_respondents"}
      = text_field_tag "respondent.phone", "{{respondent.phone}}", :disabled => true
      = text_field_tag "respondent.twitter", "{{respondent.twitter}}", :disabled => true
      = button_tag "", :type => :button, :class => "clist-remove", :disabled => true
    %li{"ng:repeat" => "respondent in respondents"}
      = text_field_tag "respondent.phone", "{{respondent.phone}}", :class => "ux-clist"
      = text_field_tag "respondent.twitter", "{{respondent.twitter}}", :class => "ux-clist"
      = button_tag "", :type => :button, :class => "clist-remove", "ng:click" => "removeRespondent(respondent)"
    %li
      = content_tag :form, "ng:submit" => "addRespondent()" do
        = text_field_tag "phone", "", :class => "ux-text", :placeholder => _("Phone number...")
        = text_field_tag "twitter", "", :class => "ux-text", :placeholder => _("Twitter username...")
        = button_tag "", :type => :button, :class => "clist-add", "ng:click" => "addRespondent()"
  %br
  %hr

  .actions
    - if wizard?
      = white_link_to _("Back"), poll_channel_path(@poll, :wizard => true)
      = grey_button _("Next"), :type => :button, "ng:click" => "nextStep()"
      = link_to _("Skip this step"), poll_path(@poll, :wizard => true), :class => "wizard-skip"
    - else
      = grey_button _("Save"), :type => :button, "ng:click" => "saveChanges(true)"
      = white_link_to _("Cancel"), @poll

:javascript
  $(document).ready(function() {
    $('#phone').placeholder();
    $('#twitter').placeholder();
  });

  function RespondentsController() {
    var scope = this;
    scope.respondents = #{respondents_list.to_json};
    scope.fixed_respondents = #{fixed_respondents_list.to_json};
    scope.only_add = #{can_edit ? "false" : "true"} ;

    $(document).ready(function() {
      window.setTimeout(function() {
        $("#phone, #twitter").focus().blur();
      }, 200);

      new AjaxUpload($('#import_csv'), {
        action: '#{import_csv_poll_respondents_path(@poll)}',
        name: 'csv',
        onSubmit: function(file, ext){
          if(ext != 'csv') {
            $.status.showError('#{_('Error: file should be in csv format')}', 6000)
            return false;
          }
        },
        onComplete: function(file, response){
          var respondents = eval(response);
          $.each(respondents, function(i, respondent)   {
            if (!scope.respondentExists(respondent)) {
              scope.respondents.push(respondent);
            }
          });
          scope.$eval();
          $("#phone, #twitter").focus().blur();
          $.status.showNotice('#{_("File successfully uploaded")}', 6000);
        }
      });
    });

    scope.respondentExists = function(phone, twitter) {
      var all_respondents = _.union(scope.fixed_respondents, scope.respondents);
      return _.any(all_respondents, function(respondent) {
        return ($.trim(respondent.phone).length > 0 && respondent.phone == phone) ||
               ($.trim(respondent.twitter).length > 0 && respondent.twitter == twitter);
      });
    }

    scope.addRespondent = function() {
      if ((!scope.respondentExists(scope.phone, scope.twitter)) && ($.trim(scope.phone) != '' || $.trim(scope.twitter) != '')) {
        scope.respondents.push({phone: scope.phone, twitter: scope.twitter});
        scope.phone = '';
        scope.twitter = '';
      }
    };

    scope.removeRespondent = function(respondent) {
      scope.respondents = _.reject(scope.respondents, function(other) {
        return other.phone == respondent.phone && other.twitter == respondent.twitter;
      });
      $("#phone, #twitter").focus().blur();
    }

    scope.removeEmptyRespondents = function() {
      scope.phones = _.reject(scope.respondents, function(respondent) {
        return $.trim(respondent.phone) == '' && $.trim(respondent.twitter) == '';
      })
    }

    scope.saveChanges = function(showNotice, nextUrl) {
      scope.removeEmptyRespondents();
      $.post('#{batch_update_poll_respondents_path}', {'respondents': scope.respondents}, function(data, textStatus) {
        if (textStatus == "success") {
          scope.onSaved();
          if (showNotice) $.status.showNotice('Respondents saved succesfully!', 6000);
          if (nextUrl) location.href = nextUrl;
        } else {
          $.status.showError('Error saving respondents', 6000);
        }
      });
    };

    scope.onSaved = function() {
      if (scope.only_add) {
        var current_respondents = scope.respondents;
        scope.respondents = [];
        angular.forEach(current_respondents, function(respondent) {
          scope.fixed_respondents.push(respondent);
        });
      }
    }

    scope.nextStep = function() {
      scope.saveChanges(false, '#{poll_path(@poll, :wizard => true)}');
    }
  }